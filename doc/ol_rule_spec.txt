Outlook Rule Specification


== Table of Contents ==

Introduction
Notation
Length fields
Timestamps
FAI Message
Rules Stream
XR Header
Element Separator
Condition 100 (0x64): Unknown
Condition 200 (0xc8): Name in To
Condition 201 (0xc9): Only to me
Condition 202 (0xca): Name not in To
Condition 203 (0xcb): From
Condition 204 (0xcc): To
Condition 205 (0xcd): Subject words
Condition 206 (0xce): Body words
Condition 207 (0xcf): Subject or body words
Condition 208 (0xd0): Flagged for action
Condition 210 (0xd2): Importance
Condition 211 (0xd3): Sensitivity
Condition 215 (0xd7): Category
Condition 220 (0xdc): Automatic reply
Condition 222 (0xde): Attachment
Condition 223 (0xdf): Form property
Condition 224 (0xe0): Size
Condition 225 (0xe1): Date
Condition 226 (0xe2): Name in Cc
Condition 227 (0xe3): Name in To or Cc
Condition 228 (0xe4): Form / Message class
Condition 229 (0xe5): Recipient words
Condition 230 (0xe6): Sender words
Condition 232 (0xe8): Header words
Condition 238 (0xee): Account
Condition 239 (0xef): Machine
Condition 240 (0xf0): Addressbook
Condition 241 (0xf1): Meeting request
Condition 245 (0xf5): RSS feed
Condition 246 (0xf6): Any category
Condition 247 (0xf7): Any RSS feed
Action 300 (0x12c): Move
Action 301 (0x12d): Soft delete
Action 302 (0x12e): Forward
Action 303 (0x12f): Reply with template
Action 304 (0x130): Show OL notification
Action 305 (0x131): Flag for action
Action 306 (0x132): Clear follow-up flag
Action 307 (0x133): Set categories
Action 310 (0x136): Play sound
Action 311 (0x137): Set importance
Action 313 (0x139): Copy
Action 314 (0x13a): Notify when read
Action 315 (0x13b): Notify when delivered
Action 316 (0x13c): Cc
Action 318 (0x13e): Defer
Action 322 (0x142): Stop rule processing
Action 324 (0x144): Redirect
Action 326 (0x146): Reply
Action 327 (0x147): Forward as attachment
Action 328 (0x148): Print
Action 330 (0x14a): Hard delete
Action 332 (0x14c): Mark as read
Action 335 (0x14f): Desktop notification
Action 337 (0x151): Set follow-up flag
Action 338 (0x152): Clear categories
Condition 400 (0x190): Receive/Send
Condition 500 (0x1f4): Except name in To
Condition 501 (0x1f5): Except only to me
Condition 502 (0x1f6): Except name not in To
Condition 503 (0x1f7): Except from
Condition 504 (0x1f8): Except to
Condition 505 (0x1f9): Except subject words
Condition 506 (0x1fa): Except body words
Condition 507 (0x1fb): Except subject or body words
Condition 508 (0x1fc): Except flagged for action
Condition 510 (0x1fe): Except importance
Condition 511 (0x1ff): Except sensitivity
Condition 515 (0x203): Except category
Condition 520 (0x208): Except automated reply
Condition 522 (0x20a): Except attachment
Condition 523 (0x20b): Except form property
Condition 524 (0x20c): Except size
Condition 525 (0x20d): Except date
Condition 526 (0x20e): Except name in Cc
Condition 527 (0x20f): Except name in To or Cc
Condition 528 (0x210): Except form / message class
Condition 529 (0x211): Except recipient words
Condition 530 (0x212): Except sender words
Condition 531 (0x213): Except header words
Condition 532 (0x214): Except account
Condition 533 (0x215): Except address book
Condition 534 (0x216): Except meeting request
Condition 537 (0x219): Except RSS feed
Condition 538 (0x21a): Except any category
Condition 539 (0x21b): Except any RSS feeds
Condition ??: Form class
Condition ??: Except form class


== Introduction ==

Rules are used to do custom processing on messages. Both incoming and outgoing
messages can be modified or otherwise acted upon. Common tasks are, for
example: sorting incoming messages into different folders, marking incoming
messages with certain colors, issuing automatic responses while out of office,
or automatic forwarding while out of office.

Such rules are first and foremost stored in the PR_RW_RULES_STREAM property
in a FAI message and constitutes Outlook's state of configuration.

In addition, rules for incoming messages are cloned to the PR_RULES_DATA
property set on a message store. (PR_RULES_TABLE is an interface-only property
that, underneath, operates on PR_RULES_DATA.) Rules that are representable
within the confines of the IID_IExchangeModifyTable interface are so stored, if
not, they are represented as a deferred action. These deferred actions are
called client-side rules in Exchange/Outlook circles, but this name is
misleading since only very few of the conditions and actions one could possibly
use in rules actually require a running client in the first place.


== Notation ==

A notation similar to C++ struct declarations with initializers is used in this
document.

Unless otherwise noted, there is no NUL termination for strings.


== Length fields ==

If an 8-bit length field has value 0xFF, there is generally a 16-bit length
field following, which overrides it. It is not known if the 3B encoding for
values below 255 is to be rejected in similar spirit how UTF-8 mandates exactly
one encoding only.

	Logical value    1B encoding    3B encoding
	-------------------------------------------
	            0    00             ff 00 00
	           ..    ..             ..
	          253    fd             ff fd 00
	          254    fe             ff fe 00
	          255    --             ff ff 00
	          256    --             ff 00 01
	          257    --             ff 01 01
	           ..    ..             ..
	        65534    --             ff fe ff
		65535    --             ff ff ff

In the XR element sections further below, this is always spelled out, in three
ways:

	1. The absence of 3B encoding has been verified:

		uint8_t len;

	2. The Outlook UI prevents the user from entering a long enough value,
	or the user cannot otherwise influence its length to observe 255-char
	behavior:

		uint8_t len;
		if (len == 0xff) /* conjecture */
			uint16_t len;

	3. The presence of 3B encoding has been verified:

		uint8_t len;
		if (len == 0xff)
			uint16_t len;


== Timestamps (PT_APPTIME) ==

A 64-bit IEEE floating point number, in which the integral part represents the
number of days since December 30, 1899, and the fractional part represents the
fraction of a day since midnight. There is no timezone information attached.

This unusual base date stems from three defining characteristics:

	* the first usable day is 1900-01-01
	* the starting index is 1
	* index 60 maps to the (non-existing) 1900-02-29,
	  and 1900-03-01 is then index 61.

A condition shown in the UI as "before 2018-01-01" is stored as
less-than(0x40e5394e...). "after 2017-12-31" is stored as
greater-than(0x40e5394d...), rather than a more straightforward
greater-or-equals(0x40e5394e...), so one will see different patterns
for effectively the same point in time.

The OL2019 UI erroneously applies the *current time* when constructing the
timestamp value from the date picker. Creating the same conditions "before
2019-01-01" twice, once at 11:58 and once at 12:00, will actually yield two
different bit patterns (0x40e5395227d2d728 and 0x40e5393222222222) and
different semantics, but the user is never told.

Detailed derivation:

	Date          Observed value 1    Observed value 2
	--------------------------------------------------
	2019-01-01    0xd27d27d2          0x40e53950
	2018-12-31    0xd27d27d2          0x40e53930
	1989-09-18    ignored             0x40e00020
	1989-09-17    ignored             0x40e00000
	1989-09-16    ignored             0x40dfffd0
	1989-09-15    ignored             0x40dfff90
	1989-09-14    ignored             0x40dfff50

OV1 has a prominent bit pattern, suggestive of a canary value for indicating
freed memory. OV2 steps in units of 32 per day. The pattern suddenly breaks
between 1989-09-16 and 1989-06-15. The DST switch however is one week away, so
that cannot be it. The step for earlier dates is 64 units per day. An increase
of precision for smaller values is strongly suggestive of a floating-point
value (as the integral part requires fewer bits, more are available for the
fractional part). By trying around, one finds that OV1 does actually belong to
the float.

OL applies the hour and minute to the timestamp, but not seconds or subseconds,
so the fractional part is always a multiple of 1/1440. The curious bit patterns
in OV1 are a result of 9 being a factor of 1440.


== FAI message ==

In the Inbox's Associated Contents folder, there is a special message
containing:

	PR_SUBJECT: "Outlook Rules Organizer"
	PR_MESSAGE_CLASS: "IPM.RuleOrganizer"
	PR_RW_RULES_STREAM: (see below)

PR_RW_RULES_STREAM contains all rules (receiving and sending), while the the
MAPI Rules Table's PR_RULE_ACTIONS property's ACTION::actDeferAction::pbData
member starts right with XR_Rule.


== Rules Stream ==

Layout:

	uint32_t magic[] =
		{0x00140000, 0x06140000, 0, 0,
		0, 0, 0, 0, 1, 1, 0};
	uint16_t numrules;
	repeat numrules {
		XR_Rule;
	};
	uint32_t tdlen;
	char16_t template_dir[tdlen];
	uint32_t magic = 0;
	double timestamp;
	uint32_t magic = 0;

@template_dir: The most recently used location from which a template file was
used. (For UI display purposes.)


== XR_Rule ==

	XR_Header
	repeat zero-or-more {
		<any XR_Condition or XR_Action>;
		if (there are more conds/actions)
			XR_Separator
	};

The size of a XR element can be variadic and generally there are no length
indiciators. The byte stream is therefore best parsed field-by-field rather
than struct-at-a-time.

The Unknown 0x190 is practically present at all times as the first element

The Condition 0x64 is practically present at all times as the second element,
even though it does not serve any observable purpose and is not displayed as
anything in the UI.

The order of elements is generally: 0x190, then all conditions, then all
actions, and only then exception conditions.


== XR_Header ==

	uint8_t magic[3];
	uint8_t locator;
	uint8_t rname_len;
	if (rname_len == 0xff)
		uint16_t rname_len;
	char16_t rule_name[rname_len];
	uint32_t rule_is_active;
	alternative {
		uint32_t ptact_recv_rule_activated[]  = {0, 0, 0, 1};
		uint32_t ptact_recv_rule_activated2[] = {0, 0, 0, 2};
		uint32_t strm_recv_rule_activated[]   = {0, 1, 0, 1};
		uint32_t strm_recv_rule_activated2[]  = {0, 1, 0, 2};
		uint32_t strm_recv_rule_activated3[]  = {0, 1, 0, 3};
		uint32_t strm_recv_rule_deactivated[] = {0, 0, 0, 0};
		uint32_t strm_send_rule_activated[]   = {0, 0, 0, 0};
		uint32_t strm_send_rule_deactivated[] = {0, 0, 0, 0};
	} magic;
	uint32_t bytecount;
	uint16_t rule_elements;
	uint16_t separator;
	if (separator == 0xffff) {
		uint16_t magic = 0;
		uint16_t rcls_len;
		char rule_class[rcls_len];
	} else if (separator == 0x8001) {
		/* ok */
	} else {
		REJECT-PARSE;
	}

@magic: The bit pattern suggests this could be a flags field.
However, before OL2019 for the first time created e0c810 rules, it warned
of backwards compatibility (once only), so this is perhaps a version field.

	0x40 0x42 0x0f    alternative 1
	0x80 0x4f 0x12    alternative 2
	0xe0 0xc8 0x10    alternative 3

@locator: a magic value

	00    via PR_RULE_ACTIONS
	06    via PR_RW_RULES_STREAM

@bytecount: The bytecount of literally everything following the bytecount
member; this includes not only the remaining fields of the XR Header, but also
all the other XR separators and elements.

@rule_elements: The number of subsequent XR elements. XR separators do not
count into this.

@rule_class: Observed only the fixed string "CRuleElement".

The OL2019 UI arbitrarily restricts rule names to 256 characters by ignoring
excess keypresses.


== XR_Separator: Element Separator ==

	uint16_t magic = 0x8001;


== XR_PropValArray: Property value array ==

This common structure appears for reference in other XR elements.

	uint32_t magic = 0;
	uint32_t numprops;
	uint32_t bytes_in_propblock;

	/* propblock begins here */
	repeat numprops {
		uint32_t proptag;
		switch (PROP_TYPE(proptag)) {
		case PT_UNICODE:
			/* Conjecture: probably also applies for PT_STRING8 */
			uint32_t magic = 0;
			uint32_t proplen;
			uint32_t offset_from_propblock;
			break;
		case PT_BINARY:
			uint32_t magic = 0;
			uint32_t offset_from_propblock;
			uint32_t magic = 0;
			break;
		case PT_LONG:
			uint32_t magic = 0;
			uint32_t propvalue;
			uint32_t magic = 0;
			break;
		}
	} propindex;

	char data[bytes_in_propblock - sizeof(propindex)];
	/* propblock ends here */

@data: This is a concatenation of the values for properties of type PT_BINARY
and PT_UNICODE, in the same order as the index. Here, PT_UNICODE strings *are*
followed by NUL, and this NUL is also counted in @proplen. Since U+0000 can
never be part of a PT_UNICODE string by definition, and solely serves as a
terminator, it needs to be appropriately subtracted during processing.


== Condition 100 (0x64): Unknown ==

	uint32_t act_kind = 0x64;
	uint32_t magic[] = {1, 0, 1};


== Condition 200 (0xc8): Name in To ==

UI label:

	EN:"where my name is in the To box"
	DE:"""die meinen Namen im Feld "An" enthält"""

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xc8;
	uint32_t magic = 0;


== Condition 201 (0xc9): Only to me ==

UI label:

	EN:"sent only to me"
	DE:"die nur an mich gesendet wurde"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xc9;
	uint32_t magic = 0;


== Condition 202 (0xca): Name not in To ==

UI label:

	EN:"where my name is not in the To box"
	DE:"""die meinen Namen im Feld "An" nicht enthält"""

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xca;
	uint32_t magic = 0;


== Condition 203 (0xcb): From ==

UI label:

	EN:"from <people or public group>"
	DE:"die von <einer Person/öffentlichen Gruppe> kommt"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xcb;
	uint32_t magic[] = {1, 0};
	uint32_t numrcpt; /* numsenders */
	repeat numrcpt {
		XR_PropValArray;
	};
	uint32_t magic[] = {1, 0};

The propvalarray for an EX entity typically includes 11 props:

	0x0c150003 (PR_RECIPIENT_TYPE),  0, 1 (MAPI_TO), 0,
	0x3001001f (PR_DISPLAY_NAME),    0, 0xb0, 0,
	0x0fff0102 (PR_ENTRYID),         0, 0x7d, 0xd0,
	0x3002001f (PR_ADDRTYPE),        0, 0x14d, 0,
	0x300b0102 (PR_SEARCH_KEY),      0, 0x64, 0x153,
	0x39fe001f (PR_SMTP_ADDRESS),    0, 0x1b7, 0,
	0x0ffe0003 (PR_OBJECT_TYPE),     0, 0x6 (MAPI_MAILUSER), 0,
	0x39000003 (PR_DISPLAY_TYPE),    0, 0 (DT_MAILUSER), 0,
	0x39050003 (PR_DISPLAY_TYPE_EX), 0, 0x40000000 (DTE_FLAG_ACL_CAPABLE), 0,
	0x3003001f (PR_EMAIL_ADDRESS),   0, 0x1d9, 0,
	0x3d010102 (PR_AB_PROVIDERS),    0, 0x10, 0x2b9,

	PR_RECIPIENT_TYPE: MAPI_TO apparently serves double purpose here
	PR_ENTRYID: 00000000dca740c8c042101ab4b908002b2fe18201000000000000002f6f3d636f6d70616e792f636e3d2e2e2e00
	PR_ADDRTYPE: L"EX"
	PR_SEARCH_KEY: "EX:/O=COMPANY/..."
	PR_SMTP_ADDRESS: L"abcdefgh@ijkl.de"
	PR_EMAIL_ADDRESS: L"/o=company/..."
	PR_AB_PROVIDERS: {02c29c57-985c-417b-e084-c5f0b5f7be02}

Note that both senders and recipients share the same representation
(here, as MAPI Recipients); this is just like how addr-spec is used
in RFC5322-style e-mail is done.

The propvalarray for an SMTP entity typically includes 12 props:

	0x0c150003 (PR_RECIPIENT_TYPE),         0, 1 (MAPI_TO), 0,
	0x3001001f (PR_DISPLAY_NAME),           0, 0xc0, 0,
	0x0fff0102 (PR_ENTRYID),                0, 0x62, 0xe0,
	0x3002001f (PR_ADDRTYPE),               0, 0x142, 0,
	0x300b0102 (PR_SEARCH_KEY),             0, 0x15, 0x14c,
	0x39fe000a (PR_SMTP_ADDRESS:PT_ERROR),  0, 0x8004010f (MAPI_E_NOT_FOUND), 0,
	0x3a710003 (PR_SEND_INTERNET_ENCODING), 0, 0, 0,
	0x3a40000b (PR_SEND_RICH_INFO),         0, 0, 0,
	0x39000003 (PR_DISPLAY_TYPE),           0, 0 (DT_MAILUSER), 0,
	0x0ff90102 (PR_RECORD_KEY),             0, 0x62, 0x161,
	0x0ffe0003 (PR_OBJECT_TYPE),            0, 0x6, 0,
	0x3003001f (PR_EMAIL_ADDRESS),          0, 0x1c3, 0,

	PR_RECIPIENT_TYPE: MAPI_TO
	PR_ENTRYID: happens to be the same as PR_RECORD_KEY
	PR_ADDRTYPE: L"SMTP"
	PR_SEARCH_KEY: "SMTP:ABCDEFG@IJKL.DE"
	PR_RECORD_KEY: 00000000812b1fa4bea310199d6e00dd010f5402000001906100620063006400650066006700400069006a006b006c002e0064006500000053004d005400500000006100620063006400650066006700400069006a006b006c002e00640065000000
	PR_EMAIL_ADDRESS: L"abcdefg@ijkl.de"


== Condition 204 (0xcc): To ==

UI label:

	EN:"sent to <people or public group>"
	DE:"die an <einer Person/öffentlichen Gruppe> gesendet wurde" [sic]

The layout is the same as From (0xcb), but with act_kind=0xcc.


== Condition 205 (0xcd): Subject words ==

UI label:

	EN:"with <specific words> in the subject"
	DE:"mit <bestimmten Wörtern> im Betreff"

Layout:

	uint32_t act_kind = 0xcd;
	uint32_t matches;
	repeat matches {
		uint32_t possibly_flags = 0;
		uint8_t mlen;
		if (mlen == 0xff)
			uint16_t mlen;
		char16_t substring[mlen];
	} m;

The UI offers no way to set any flags, and based upon the UI text and observed
runtime behavior, FL_IGNORECASE|FL_SUBSTRING is always in effect with flags==0.

The OL2019 UI arbitrarily restricts substrings to 255 characters by ignoring
excess keypresses.


== Condition 206 (0xce): Body words ==

UI label:

	EN:"with <specific words> in the body"
	DE:"mit <bestimmten Wörtern> im Text"

The layout is the same as Subject (0xcd), but with act_kind=0xce.


== Condition 207 (0xcf): Subject or body words ==

UI label:

	EN:"with <specific words> in the subject or body"
	DE:"mit <bestimmten Wörtern> im Betreff oder Text"

The layout is the same as Subject (0xcd), but with act_kind=0xcf.


== Condition 208 (0xd0): Flagged for action ==

UI label:

	EN:"flagged for <action>"
	DE:"die mit <einer Aktion> gekennzeichnet ist"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xd0;
	uint32_t magic[] = {1, 0, 0};
	uint8_t nlen;
	if (nlen == 0xff)
		uint16_t nlen;
	char16_t action[nlen];
	uint32_t magic = 1;


== Condition 210 (0xd2): Importance ==

UI label:

	EN:"marked as <importance>"
	DE:"die mit <Priorität> markiert ist"

Layout:

	uint32_t act_kind = 0xd2;
	uint32_t magic[] = {1, 0};
	enum : uint32_t {
		IMPORTANCE_LOW = 0
		IMPORTANCE_MEDIUM = 1,
		IMPORTANCE_HIGH = 2,
	};


== Condition 211 (0xd3): Sensitivity ==

UI label:

	EN:"marked as <sensitivity>"
	DE:"die mit <Vertraulichkeit> markiert ist"

Layout:

	uint32_t act_kind = 0xd3;
	uint32_t magic[] = {1, 0};
	enum : uint32_t {
		SENSITIVITY_NORMAL = 0
		SENSITIVITY_PERSONAL = 1,
		SENSITIVITY_PRIVATE = 2,
		SENSITIVITY_COMPANY_CONFIDENTIAL = 3,
	};


== Condition 215 (0xd7): Category ==

UI label:

	EN:"assigned to <category> category"
	DE:"die Kategorie <Kategorie zugeordnet ist>"

Layout:

	uint32_t act_kind = 0xd7;
	uint32_t magic[] = {1, 0};
	uint8_t cname_len;
	if (cname_len == 0xff)
		uint16_t cname_len;
	char16_t categories[cname_len];

@categories is a semicolon-separated string of categories. As a consequence,
category names are not allowed to contain semicolons, and the OL2019 UI
inhibits the keypress.

All specified @catgories must be present on the message for the match to occur.
(Labeling: DE:"Nach Erhalt einer Nachricht ... die Kategorie C1 _und_ C2
zugeordnet ist...")


== Condition 220 (0xdc): Automatic reply ==

UI label:

	EN:"which is an automatic reply"
	DE:"die eine automatische Antwort ist"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xdc;
	uint32_t magic = 0;


== Condition 222 (0xde): Attachment ==

UI label:

	EN:"which has an attachment"
	DE:"mit einer Anlage"

Layout:

	uint32_t act_kind = 0xde;
	uint32_t magic = 0;


== Condition 223 (0xdf): Form property ==

UI label:

	EN:"with <selected properties> of documents or forms"
	DE:"mit Dokument-/Formular-<Eigenschaften>"

Layout:

	uint32_t act_kind = 0xdf;
	uint32_t magic[] = {1, 0};
 	uint8_t flen;
	if (flen == 0xff)
		uint16_t flen;
	char16_t forms[flen];
	uint16_t numprops;
	repeat numprops {
		uint8_t flen;
		if (flen == 0xff) /* conjecture */
			uint16_t flen;
		char16_t fieldname[flen];
		uint32_t proptag;

		enum : uint32_t {
			CONTAINS = 0,
			IS_EQUAL = 1,
			NOT_CONTAINS = 2,
		} string_match_type;
		uint8_t svlen;
		if (svlen == 0xff) /* conjecture */
			uint16_t svlen;
		char16_t v_string[svlen];
		enum : uint32_t {
			EQ = 0,
			NE = 1,
			LE = 2, /* called "at most" */
			GE = 3, /* called "at least" */
			GT = 4,
			LT = 5,
		} long_match_type;
		uint32_t magic = 0;
		uint32_t v_long;
		uint32_t v_boolean; /* seemingly inverted */
		uint32_t magic = 1;
		enum : uint32_t {
			BEFORE = 0,
			AFTER = 1,
		} time_match_type;
		uint32_t magic = 0;
		double v_apptime;
		uint32_t magic = 0;
	};
	uint32_t classcount;
	repeat classcount {
		uint8_t clen;
		if (clen == 0xff) /* conjecture */
			uint16_t clen;
		char msgclass[clen];
	};

@forms: a semicolon-space-separated list of forms to load
(e.g. "Aufgabe annehmen; InfoPath-Formular").

@flen: (When constructing custom forms, Outlook arbitrarily restricts field names to 32
characters by ignoring excess keypresses. A clen >= 255 was not observable.)

@fieldname: Descriptive string for the property/field.

@proptag:
	0x68010003	IPM.Outlook.Recall DE:"Nachrichtenrückruf: Kennzeichnungen"
	0x6803000b	IPM.Outlook.Recall DE:"Nachrichtenrückruf: Sendebericht"
	0x8.......	various named properties

Even though some properties have PROP_TYPE()==PT_SYSTIME, the value stored in
the stream has PT_APPTIME semantics.

@string_match_type: For PT_UNICODE, contains the choice the user made.
Otherwise, 0.

@svlen: For PT_UNICODE, contains the length of the substring following.
Otherwise, 0.

@v_string: For PT_UNICODE, contains the choice the user made.

@long_match_type: For PT_LONG, contains the choice the user made. Otherwise, 0.

@v_long: For PT_LONG, contains the choice the user made. Otherwise, 0.

@v_boolean: For PT_BOOLEAN, contains the inversion of the choice the user made
(Yes=0, No=1). Otherwise, 0.

@v_apptime: For PT_SYSTIME/PT_APPTIME, contains the date/time choice the user
made. Otherwise, OL fills this with the creation date of the subcondition.


== Condition 224 (0xe0): Size ==

UI label:

	EN:"with a size <in a specific range>"
	DE:"mit <einer bestimmten Größe> (KB)"

Layout:

	uint32_t act_kind = 0xe0;
	uint32_t magic[] = {1, 0};
	uint32_t min_size_kb;
	uint32_t max_size_kb;


== Condition 225 (0xe1): Date ==

UI label:

	EN:"received <in a specific date span>"
	DE:"die <in einem bestimmten Zeitraum> erhalten wurde"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xe1;
	uint32_t magic[] = {1, 0};
	uint32_t test_after;
	uint32_t magic = 0;
	double ts_after;
	uint32_t test_before;
	uint32_t magic = 0;
	double ts_before;

@test_after: boolean whether or not to run a comparison "NOW > @ts_after".

@test_before: boolean whether or not to run a comparison "NOW < @ts_before".

@ts_after: timestamp for the "is-after" check. See the "Timestamp" section
for details.

@ts_before: timestamp for the "is-before" check. Curiously, this field,
together with the ts_before field from the Except date condition (Element
0x20d), are the only two timestamps which have its fractional part correctly
set to zero by the OL2019 Date Picker.


== Condition 226 (0xe2): Name in Cc ==

UI label:

	EN:"where my name is in the Cc box"
	DE:"""die meinen Namen im Feld "Cc" enthält"""

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xe2;
	uint32_t magic = 0;


== Condition 227 (0xe3): Name in To or Cc ==

UI label:

	EN:"where my name is in the To or Cc box"
	DE:"""die meinen Namen im Feld "An" oder "Cc" enthält"""

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xe3;
	uint32_t magic = 0;


== Condition 228 (0xe4): Form / message class ==

UI label:

	EN:"uses the <form name> form"
	DE:"die das Formular <Formularname> verwendet"

Layout:

	uint32_t act_kind = 0xe4;
	uint32_t numforms;
	uint32_t magic = 0;
	repeat numforms {
		uint8_t nlen;
		if (nlen == 0xff)
			uint16_t nlen;
		char16_t name[nlen];
		uint8_t clen;
		if (clen == 0xff) /* conjecture */
			uint16_t clen;
		char msgclass[clen];
	};

The OL2019 UI, when saving forms, arbitrarily restricts form names to 128
characters by ignoring excess keypresses. A nlen >= 255 was therefore not
observable. Through the Options menu, one can subsequently edit the display
name (but not the message class) and set longer names.

If the message has at least one of the forms (same as message class?) presented
in this condition element, then the condition will already match.

@name: The display name of the form.

@msgclass: The form's message class. List of classes observed so far:

	IPM
		DE:"Generisches Standardformular"
	IPM.Activity (C*)
		EN:"Journal entry"
		DE:"Journaleintrag"
	IPM.Appointment (C*)
		EN:"Appointment"
		DE:"Termin"
	IPM.Conflict
		EN:"Conflict Message"
		DE:"Konfliktnachricht"
	IPM.Conflict.Resolution.Message
		EN:"Conflict resolution form"
		DE:"Formular zur Konfliktbeseitigung"
	IPM.Contact (C*)
		EN:"Contact"
		DE:"Kontakt"
	IPM.DistList
		DE:"Verteilerliste"
	IPM.Document
		DE:"Dokument"
	IPM.InfoPathForm
		DE:"InfoPath-Formular"
	IPM.Note (C*)
		EN:"Message"
		DE:"Nachricht"
	IPM.Note.Mobile.MMS
		EN:"Multimedia Message"
		DE:"Multimedianachricht (MMS)"
	IPM.Note.Mobile.SMS
		DE:"Textnachricht (SMS)"
	IPM.Note.RECEIPT.SMIME
		DE:"SMIME-Bestätigung"
	IPM.Note.Rules.OofTemplate.Microsoft
		EN:"Automatic Replies template"
		DE:"Vorlage für automatische Antworten"
	IPM.Note.Rules.ReplyTemplate.Microsoft
		EN:"Rule reply template"
		DE:"Regelantwortvorlage"
	IPM.Note.SMIME
		DE:"SMIME-Verschlüsselungsformular"
	IPM.Note.SMIME.MultipartSigned
		DE:"Formular SMIME digital signiert"
	IPM.Note.Secure
		DE:"Verschlüsselte Nachricht"
	IPM.Note.Secure.Sign
		EN:"Digitally signed message"
		DE:"Nachricht mit digitaler Signatur"
	IPM.OLE.CLASS.{00061055-0000-0000-C000-000000000046}
		DE:"Ausnahme"
	IPM.Outlook.Recall
		EN:"Recall Message Form"
		DE:"Formular zum Nachrichtenrückruf"
	IPM.POST (C*)
		DE:"Bereitstellen"
	IPM.POST.RSS (C*)
		EN:"RSS Article"
		DE:"RSS-Artikel"
	IPM.Recall
		EN:"Message Recall Report"
		DE:"Nachrichtenrückrufbericht"
	IPM.Remote
		EN:"Remote"
		DE:"Remote"
	IPM.Resend
		EN:"Resend"
		DE:"Noch mal senden"
	IPM.Schedule.Meeting.Canceled
		EN:"Meeting Cancellation"
		DE:"Besprechungsabsage"
	IPM.Schedule.Meeting.Request (C*)
		EN:"Meeting Request"
		DE:"Besprechungsanfrage"
	IPM.Schedule.Meeting.Request.Neg
		EN:"Decline Meeting Response"
		DE:"Besprechung ablehnen"
	IPM.Schedule.Meeting.Resp.Pos
		EN:"Accept Meeting Response"
		DE:"Besprechungseinladung annehmen"
	IPM.Schedule.Meeting.Resp.Tent
		DE:"Besprechungszusage mit Vorbehalt"
	IPM.Sharing
		EN:"Sharing Request"
		DE:"Freigabeanfrage"
	IPM.StickyNote
		EN:"Note"
		DE:"Notiz"
	IPM.Task (C*)
		DE:"Aufgabe"
	IPM.TaskRequest (C*)
		DE:"Aufgabenanfrage"
	IPM.TaskRequest.Accept
		DE:"Aufgabe annehmen"
	IPM.TaskRequest.Decline
		DE:"Aufgabe ablehnen"
	IPM.TaskRequest.Update
		DE:"Aufgabe aktualisieren"
	REPORT
		DE:"Bericht"

Custom forms may be created from the classes/forms designated C*. The resulting
message class will use that prefix. For example, deriving from the "IPM.Note"
form and saving it under the name "MyForm" will make it available under the
class name "IPM.Note.MyForm".


== Condition 229 (0xe5): Recipient words ==

UI label:

	EN:"with <specific words> in the recipient's address"
	DE:"mit <bestimmten Wörtern> in der Empfängeradresse"

The layout is the same as Subject words (0xcd), but with act_kind=0xe5.


== Condition 230 (0xe6): Sender words ==

UI label:

	EN:"with <specific words> in the sender's address"
	DE:"mit <bestimmten Wörtern> in der Absenderadresse"

UI behavior:

	Only selectable for receive rules.

The layout is the same as Subject words (0xcd), but with act_kind=0xe6.


== Condition 232 (0xe8): Header words ==

UI label:

	EN:"with <specific words> in the message header"
	DE:"mit <bestimmten Wörtern> im Nachrichtenkopf"

UI behavior:

	Only selectable for receive rules.

The layout is the same as Subject (0xcd), but with act_kind=0xe8.


== Condition 238 (0xee): Account ==

UI label:

	EN:"though the <specified> account"
	DE:"über Konto <Kontoname>"

UI behavior:

	When this element is selected, Outlook also selects "Condition:
	Machine", and one cannot deselect Machine.

Layout:

	uint32_t act_kind = 0xee;
	uint32_t magic[] = {1, 0};
	uint8_t alen;
	if (alen == 0xff) /* conjecture */
		uint16_t alen;
	char16_t account_name[alen];
	uint8_t abc_len;
	if (abc_len == 0xff) /* conjecture */
		uint16_t abc_len;
	char abc[abc_len];

(The MAPI control panel limits profile names to 63 characters, by the way.)

@account_name: An account _within_ the current MAPI profile, specifically
the account's display name (which is usually an e-mail address and which
the MAPI/OL config dialogs refuse to make editable).

@abc: Content unclear. It was observed to be a 10-digit number represented as
an ASCII string.


== Condition 239 (0xef): Machine ==

UI label:

	EN:"on this computer only"
	DE:"nur auf diesem Computer"

Layout:

	uint32_t act_kind = 0xef;
	uint32_t magic[] = {1, 0};
	unsigned char some_guid[16];


== Condition 240 (0xf0): Addressbook ==

UI label:

	EN:"sender is in <specified> Address Book"
	DE:"deren Versender im Adressbuch <Adressbuchname> vorkommt"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xf0;
	uint32_t magic[] = {1, 0};
	uint32_t eidlen;
	char eid[eidlen];
	uint8_t nlen;
	if (nlen == 0xff) /* conjecture */
		uint16_t nlen;
	char16_t name[nlen];

@eid: for example,
00000000  00 00 00 00 87 12 f5 ef  5b 95 8f 43 94 a0 89 8c  |........[..C....|
00000010  07 4d 16 c4 01 00 00 00  00 01 00 00 2f 67 75 69  |.M........../gui|
00000020  64 3d 33 34 45 46 39 34  38 39 30 34 44 42 34 33  |d=34EF948904DB43|
00000030  37 37 39 31 32 36 33 41  37 34 42 42 46 39 31 32  |7791263A74BBF912|
00000040  34 42 00                                          |4B.|
00000043

@name: for example, "Global Addressbook"


== Condition 241 (0xf1): Meeting request ==

UI label:

	EN:"which is a meeting invitation or update"
	DE:"die eine Besprechungsanfrage oder -aktualisierung ist"

Layout:

	uint32_t act_kind = 0xf1;
	uint32_t magic = 0;


== Condition 245 (0xf5): RSS feed ==

UI label:

	EN:"from RSS Feeds with <specified text> in the tiele"
	DE:"aus RSS-Feeds mit <angegebener Text> im Titel" [sic]

Layout:

	uint32_t act_kind = 0xf5;
	uint32_t mgc[] = {1, 0};
	uint8_t nlen;
	if (nlen == 0xff)
		uint16_t nlen;
	char16_t name[nlen];


== Condition 246 (0xf6): Any category ==

UI label:

	EN:"assigned to any category"
	DE:"einer beliebigen Kategorie zugewiesen"

Layout:

	uint32_t act_kind = 0xf6;
	uint32_t magic = 0;

Matches if the message has any category set. (This only works for messages
received directly through MAPI or as TNEF.)


== Condition 247 (0xf7): Any RSS feed ==

UI label:

	EN:"from any RSS Feed"
	DE:"von beliebigen RSS-Feeds"

Layout:

	uint32_t act_kind = 0xf7;
	uint32_t magic = 0;


== Action 300 (0x12c): Move message ==

UI label:

	EN:"move it to the <specified> folder"
	DE:"diese in den Ordner <Zielordner> verschieben"

Layout:

	uint32_t act_kind = 0x12c;
	uint32_t magic[] = {1, 0};
	uint32_t feid_len;
	char folder_eid[feid_len];
	uint32_t seid_len;
	char store_eid[seid_len];
	uint8_t fname_len;
	if (fname_len == 0xff)
		uint16_t fname_len;
	char16_t folder_name[fname_len];
	uint32_t magic = 0;

The OL2019 UI's left pane arbitrarily restricts folder names to 127 characters
by ignoring excess keypresses. The folder property dialog (via context menu)
allows longer names, but still arbitrarily restricts folder names to 255
characters by ignoring excess keypresses. Longer names can be set up using
MFCMAPI.


== Action 301 (0x12d): Soft delete (Move to wastebasket) ==

UI label:

	EN:"delete it"
	DE:"diese löschen"

Layout:

	uint32_t act_kind = 0x12d;
	uint32_t magic = 0;


== Action 302 (0x12e): Forward message ==

UI label:

	DE:"diese an <einer Person/öffentlichen Gruppe> weiterleiten" [sic]

Layout:

	uint32_t act_kind = 0x12e;
	uint32_t magic[] = {1, 0};
	uint32_t numrcpt;
	repeat numrcpt {
		XR_PropValArray;
	};
	uint32_t magic[] = {0, 0};

The propvalarray for a recipient is the same as for a sender (0xcb).


== Action 303 (0x12f): Reply with template ==

UI label:

	EN:"reply using <a specific template>"
	DE:"diese mit <einer bestimmten Vorlage> beantworten"

UI behavior:

	The OL2019 file dialog's text field restricts entering pathnames to 260
	characters by ignoring excess keypresses. Furthermore, the UI rejects
	pathnames longer than 255 characters with a modal error dialog. The
	pathname from the dialog is used as-is, so there is no automatic
	conversion between drive letters and \\unc\paths.

Layout:

	uint32_t act_kind = 0x12f;
	uint32_t magic[] = {1, 0};
	uint8_t plen;
	if (plen == 0xff)
		uint16_t plen;
	char16_t pathname[plen];


== Action 304 (0x130): Show Outlook notification ==

UI label:

	EN:"display <a specific message> in the New Item Alert window"
	DE:"Im Benachrichtigungsfenster für neue Elemente <diesen Text> anzeigen"

Layout:

	uint32_t act_kind = 0x130;
	uint32_t magic[] = {1, 0};
	uint8_t tlen;
	if (tlen == 0xff)
		uint16_t tlen;
	char16_t text[tlen];

The OL2019 UI restricts entering messages to 65536 characters by ignoring
excess keypresses. When trying to save such a large text, OL will claim
Exchange Server has a problem with it. The rule stays deactivated. Deactivated
client-side rules are not present in the MAPI Rules Table (PR_ACTIONS), but
only in the Rule FAI Message's PR_RW_RULES_STREAM property. Bringing up the
rules dialog in OL again shows the message text has been silently truncated to
65535 characters, which suggests that there is no 7B extension to the 3B
encoding of length fields.

There are additional limitations with PR_ACTIONS; only some 14539 bytes of the
action::actDeferAction::pbData stream are returned by MSMAPI.


== Action 305 (0x131): Flag for action ==

UI label:

	EN:"flag message for <action in a number of days>"
	DE:"diese mit <einer Aktion in ... Tagen> kennzeichnen

Layout:

	uint32_t act_kind = 0x131;
	uint32_t magic[] = {1, 0};
	uint32_t days;
	uint8_t nlen;
	if (nlen == 0xff)
		uint16_t nlen;
	char16_t action[nlen];
	uint32_t magic = 0;


== Action 306 (0x132): Clear followup flag ==

UI label:

	EN:"clear the Message Flag"
	DE:"die Nachrichtenkennzeichnung löschen"

Layout:

	uint32_t act_kind = 0x132;
	uint32_t magic = 0;


== Action 307 (0x133): Set categories ==

UI label:

	EN:"assign it to the <category> category"
	DE:"diese der Kategorie <Kategorie> zuordnen"

Layout:

	uint32_t act_kind = 0x133;
	uint32_t magic[] = {1, 0};
	uint8_t clen;
	if (clen == 0xff)
		uint16_t clen;
	char16_t categories[clen];

@categories: This is a semicolon-separated string of categories that shall be
set on the message. (Property is PS_PUBLIC_STRINGS:Keywords:PT_MV_UNICODE)
For this reason, category names themselves cannot have a semicolon in them.
According to MS-OXOCFG, the following characters are also forbidden:
U+061B (ARABIC SEMICOLON), U+FE54 (SMALL SEMICOLON) and U+FF1B (FULLWIDTH
SEMICOLON).

The OL2019 UI restricts entering category names by ignoring semicolon
keypresses.

Category name-to-color mappings are stored in a FAI message
[ol_category_spec.txt].


== Action 310 (0x136): Play sound ==

UI label:

	EN:"play <a sound>"
	DE:"<einen Sound> wiedergeben"

UI behavior:

	When this element is selected, Outlook also selects
	"Condition: Machine". However, one can deselect Machine by
	going back, and then forward again.

The layout is the same as Reply with Template (0x12f), but with act_kind=0x136.


== Action 311 (0x137): Set importance ==

UI label:

	EN:"mark it as <importance>"
	DE:"diese als <Priorität> markieren"

Layout:

	uint32_t act_kind = 0x137;
	uint32_t magic[] = {1, 0};
	enum : uint32_t {
		IMPORTANCE_LOW = 0,
		IMPORTANCE_MEDIUM = 1,
		IMPORTANCE_HIGH = 2,
	} importance;


== Action 313 (0x139): Copy ==

UI label:

	EN:"move a copy to the <specified> folder"
	DE:"eine Kopie davon in den Ordner <Zielordner> verschieben"

The layout is the same as Move (0x12c), but with act_kind=0x139.


== Action 314 (0x13a): Notify when read ==

UI label:

	EN:"notify me when it is read"
	DE:"mich benachrichtigen, wenn sie gelesen wurde"

UI behavior:

	Only selectable for send rules.

Layout:

	uint32_t act_kind = 0x13a;
	uint32_t magic = 0;


== Action 315 (0x13b): Notify when delivered ==

UI label:

	EN:"notify me when it is delivered"
	DE:"mich benachrichtigen, wenn sie erhalten wurde"

UI behavior:

	Only selectable for send rules.

Layout:

	uint32_t act_kind = 0x13b;
	uint32_t magic = 0;


== Action 316 (0x13c): Cc ==

UI label:

	EN:"Cc the message to <people or public group>"
	DE:"diese an <einer Person/öffentlichen Gruppe> kopieren (Cc)" [sic]

UI behavior:

	Only selectable for send rules.

The layout is the same as Forward (0x12e), but with act_kind=0x13c.

PR_RECIPIENT_TYPE in the propvalarray still has value MAPI_TO rather than
MAPI_CC!


== Action 318 (0x13e): Defer ==

UI label:

	EN:"defer delivery by <a number of> minutes"
	DE:"diese <eine Anzahl von> Minuten verzögert übermitteln"

UI behavior:

	Only selectable for send rules.

Layout:

	uint32_t act_kind = 0x13e;
	uint32_t magic[] = {1, 0};
	uint32_t minutes;


== Action 322 (0x142): Stop rule processing ==

UI label:

	EN:"stop processing more rules"
	DE:"keine weiteren Regeln anwenden"

UI behavior:

	Understandably, Outlook always ensures this action is at the end of the
	action list.

Layout:

	uint32_t act_kind = 0x142;
	uint32_t magic = 0;


== Action 324 (0x144): Redirect ==

UI label:

	EN:"redirect it to <people or public group>"
	DE:"diese umleiten an <einer Person/öffentlichen Gruppe>" [sic]

UI behavior:

	The OL2019 UI does not permit mixing this action with other actions not
	representable as server-side rules.

Layout:

The layout is the same as Forward (0x12e), but with act_kind=0x144.


== Action 326 (0x146): Reply ==

UI label:

	EN:"have server reply using <a specific message>"
	DE:"diese vom Server mit <einer Nachricht> beantworten"

UI behavior:

	The OL2019 UI does not permit mixing this action with other actions not
	representable as server-side rules.

Layout:

	uint32_t act_kind = 0x146;
	uint32_t magic[] = {1, 0};
	uint32_t eidlen;
	char eid[eidlen];
	uint8_t slen;
	if (slen == 0xff)
		uint16_t slen;
	char16_t subject[slen];

The associated message referenced by @eid is stored in the inbox's Associated
Contents and has a PR_MESSAGE_CLASS of
"IPM.Note.Rules.ReplyTemplate.Microsoft".


== Action 327 (0x147): Forward as attachment ==

UI label:

	DE:"diese als Anlage an <einer Person/öffentlichen Gruppe>
	weiterleiten" [sic]

The layout is the same as Forward (0x12e), but with act_kind=0x147.


== Action 328 (0x148): Print ==

UI label:

	EN:"print it"
	DE:"diese drucken"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x148;
	uint32_t magic = 0;


== Action 330 (0x14a): Hard delete ==

UI label:

	EN:"permanently delete it"
	DE:"diese endgültig löschen"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x14a;
	uint32_t magic = 0;



== Action 332 (0x14c): Mark as read ==

UI label:

	EN:"mark it as read"
	DE:"als gelesen markieren"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x14c;
	uint32_t magic = 0;


== Action 335 (0x14f): Desktop notfication ==

UI label:

	EN:"display a Desktop Alert"
	DE:"Desktopbenachrichtigung anzeigen"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x14f;
	uint32_t magic = 0;


== Action 337 (0x151): Set follow-up flag ==

UI label:

	EN:"flag message for <follow up at this time>"
	DE:"Nachricht kennzeichnen für <zu diesem Zeitpunkt nachverfolgen>"

UI behavior:

	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x151;
	uint32_t magic[] = {1, 0};
	enum : uint32_t {
		FOLLOWUP_TODAY = 0x1,
		FOLLOWUP_TOMORROW = 0x2,
		FOLLOWUP_THISWEEK = 0x3,
		FOLLOWUP_NEXTWEEK = 0x4,
		FOLLOWUP_NODATE = 0x7,
		FOLLOWUP_DONE = 0xa,
	};
	uint8_t fu_name_len;
	char16_t fu_name[fu_name_len];


== Action 338 (0x152): Clear categories ==

UI label:

	EN:"clear message's categories"
	DE:"Kategorien der Nachricht löschen"

Layout:

	uint32_t act_kind = 0x152;
	uint32_t magic = 0;


== Condition 400 (0x190): Receive/Send ==

UI label:

	EN:"Apply this rule after the message arrives"
	DE:"Nach Erhalt einer Nachricht"
	EN:"Apply this rule after I send the message"
	DE:"Nach dem Senden einer Nachricht"

Layout:

	uint32_t act_kind = 0x190;
	uint32_t magic[] = {1, 0};
	uint32_t flagbits;

@flagbits:
	0x01: message was received
	0x04: message was sent


== Condition 500 (0x1f4): Except name in To ==

UI label:

	EN:"except where my name is in the To box"
	DE:"""außer wenn mein Name im Feld "An" steht"""

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x1f4;
	uint32_t magic = 0;


== Condition 501 (0x1f5): Except only to me ==

UI label:

	EN:"except if sent only to me"
	DE:"außer wenn sie nur an mich gesendet wurde"

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0xc9;
	uint32_t magic = 0;


== Condition 502 (0x1f6): Except name not in To ==

UI label:

	EN:"except where my name is in the To box"
	DE:"""außer wenn mein Name nicht im Feld "An" steht"""

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x1f4;
	uint32_t magic = 0;


== Condition 503 (0x1f7): Except from ==

UI label:

	EN:"except if from <people or public group>"
	DE:"außer diese ist von ..."

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

The layout is the same as From (0xcb), but with act_kind=0x1f7.


== Condition 504 (0x1f8): Except to ==

UI label:

	EN:"except if sent to <people or public group>"
	DE:"außer bei Versand an <einer Person/öffentlichen Gruppe>" [sic]

UI behavior:

	Availability: OL2007 OL2019
	Only selectable for receive rules.

The layout is the same as To (0xcc), but with act_kind=0x1f8.


== Condition 505 (0x1f9): Except subject words ==

UI label:

	EN:"except if the subject contains <specific words>"
	DE:"außer mit <bestimmten Wörtern> im Betreff"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Subject words (0xcd), but with act_kind=0x1f9.


== Condition 506 (0x1fa): Except body words ==

UI label:

	EN:"except if the body contains <specific words>"
	DE:"außer mit <bestimmten Wörtern> im Text"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Subject words (0xcd), but with act_kind=0x1fa.


== Condition 507 (0x1fb): Except subject or body words ==

UI label:

	EN:"except if the subject or body contains <specific words>"
	DE:"außer mit <bestimmten Wörtern> im Betreff oder Text"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Subject words (0xcd), but with act_kind=0x1fb.


== Condition 508 (0x1fc): Except flagged for action ==

UI label:

	EN:"except if it is flagged for <action>"
	DE:"außer wenn sie mit <einer Aktion> markiert ist"

UI behavior:

	Availability: !OL2007 OL2019

The layout is the same as Flagged for action (0xd0), but with act_kind=0x1fc.


== Condition 510 (0x1fe): Except importance ==

UI label:

	EN:"except if it is marked as <importance>"
	DE:"außer wenn mit <Priorität> markiert"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Importance (0xd2), but with act_kind=0x1fe.


== Condition 511 (0x1ff): Except sensitivity ==

UI label:

	EN:"except if it is marked as <sensitivity>"
	DE:"außer wenn mit <Vertraulichkeit> markiert"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Sensitivity (0xd3), but with act_kind=0x1ff.


== Condition 515 (0x203): Except category ==

UI label:

	EN:"except if assigned to <category> category"
	DE:"außer wenn sie Kategorie <Kategorie> zugeordnet ist"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Category (0xd7), but with act_kind=0x203.


== Condition 520 (0x208): Except automated reply ==

UI label:

	DE:"außer es ist eine automatische Antwort"

UI behavior:

	Availability: !OL2007 OL2019

Layout:

	uint32_t act_kind = 0x208;
	uint32_t magic = 0;


== Condition 522 (0x20a): Except attachment ==

UI label:

	EN:"except if it has an attachment"
	DE:"außer es ist eine Anlage dabei"

UI behavior:

	Availability: OL2007 OL2019

Layout:

	uint32_t act_kind = 0x20a;
	uint32_t magic = 0;


== Condition 523 (0x20b): Except form property ==

UI label:

	EN:"except with <selected properties> of documents or forms"
	DE:"außer mit Dokument-/Formular-<Eigenschaften>"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Form property (0xd4), but with act_kind=0x20b.


== Condition 524 (0x20c): Except size ==

UI label:

	EN:"except with a size <in a specific range>"
	DE:"außer mit <einer bestimmten Größe> (KB)"

UI behavior:

	Availability: OL2007 OL2019

Layout:

	uint32_t act_kind = 0x20c;
	uint32_t magic[] = {1, 0};
	uint32_t min_size_kb;
	uint32_t max_size_kb;


== Condition 525 (0x20d): Except date ==

UI label:

	DE:"außer bei Erhalt <in einem bestimmten Zeitraum>"

UI behavior:

	Availability: !OL2007 OL2019

The layout is the same as Date (0xe1), but with act_kind=0x20d.


== Condition 526 (0x20e): Except name in Cc ==

UI label:

	EN:"except where my name is in the Cc box"
	DE:"""außer wenn mein Name im Feld "Cc" steht"""

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x20e;
	uint32_t magic = 0;


== Condition 527 (0x20f): Except name in To or Cc ==

UI label:

	EN:"except if my name is in the To or Cc box"
	DE:"""außer wenn mein Name im Feld "An" oder "Cc" steht"""

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

Layout:

	uint32_t act_kind = 0x20f;
	uint32_t magic = 0;


== Condition 528 (0x210): Except form / message class ==

UI label:

	EN:"except if it uses the <form name> form"
	DE:"außer diese verwendet das Formular <Formularname>"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Form (0xe4), but with act_kind=0x210.


== Condition 529 (0x211): Except recipient words ==

UI label:

	EN:"except with <specified words> in the recipient's address"
	DE:"außer mit <bestimmten Wörtern> in der Empfängeradresse"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as Subject words (0xcd), but with act_kind=0x211.


== Condition 530 (0x212): Except sender words ==

UI label:

	EN:"except with <specified words> in the sender's address"
	DE:"außer mit <bestimmten Wörtern> in der Absenderadresse"

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

The layout is the same as Subject words (0xcd), but with act_kind=0x211.


== Condition 531 (0x213): Except header words ==

UI label:

	EN:"except if the message header contains <specific words>"
	DE:"außer mit <bestimmten Wörtern> im Nachrichtenkopf"

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

The layout is the same as Subject words (0xcd), but with act_kind=0x213.


== Condition 532 (0x214): Except account ==

UI label:

	EN:"except through the <specified> account"
	DE:"außer wenn über Konto <Kontoname> erhalten"

UI behavior:

	Availability: OL2007 OL2019
	When this element is selected, Outlook also selects
	"Condition: Machine". However, one can deselect Machine by
	going back, and then forward again.

The layout is the same as Account (0xee), but with act_kind=0x214.


== Condition 533 (0x215): Except address book ==

UI label:

	DE:"außer der Versender ist im Adressbuch <Adressbuchname>"

UI behavior:

	Availability: !OL2007 OL2019
	Only selectable for receive rules.

The layout is the same as Address book (0xf0), but with act_kind=0x215.


== Condition 534 (0x216): Except meeting request ==

UI label:

	EN:"except if it is a meeting invitation or update"
	DE:"außer es handelt sich um eine Besprechungsanfrage oder -aktualisierung"

UI behavior:

	Availability: OL2007 OL2019

Layout:

	uint32_t act_kind = 0x216;
	uint32_t magic = 0;


== Condition 537 (0x219): Except RSS feed ==

UI label:

	EN:"except if it is from RSS Feeds with <specified text> in the title"
	DE:"außer von RSS-Feeds mit '<angegebener Text>' im Titel"

UI behavior:

	Availability: OL2007 OL2019

The layout is the same as RSS feed (0xf5), but with act_kind=0x219.


== Condition 538 (0x21a): Except any category ==

UI label:

	EN:"except if assigned to any category"
	DE:"außer bei Zuweisung zu einer beliebigen Kategorie"

UI behavior:

	Availability: OL2007 OL2019

Layout:

	uint32_t act_kind = 0x21a;
	uint32_t magic = 0;


== Condition 539 (0x21b): Except any RSS feed ==

UI label:

	EN:"except if from any RSS Feed"
	DE:"außer von beliebigen RSS-Feeds"

UI behavior:

	Availability: OL2007 OL2019

Layout:

	uint32_t act_kind = 0x21b;
	uint32_t magic = 0;


== Condition ??: Form class ==

UI label:

	EN:?
	DE:"vom Formulartyp '<bestimmt>'"

UI behavior:

	In OL2019, clicking the "<...>" hyperlink leads to no dialog and no
	action. The feature is practically not observable.


== Condition ??: Except form class ==

UI label:

	EN:?
	DE:"außer Formulare vom Typ '<bestimmt>'"

UI behavior:

	In OL2019, clicking the "<...>" hyperlink leads to no dialog and no
	action. The feature is practically not observable.

The layout is presumably the same as Form class.
